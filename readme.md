## ‡∏™‡∏£‡∏∏‡∏õ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏à‡∏î‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≠‡∏ö (Wk 9 - 12)
### 1. FreeRTOS (Week 12) üöÄ ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÄ‡∏ô‡πâ‡∏ô "‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á" ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Task
---
## ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ã‡∏õ‡∏ï‡πå‡∏´‡∏•‡∏±‡∏Å:

- ### Multitasking: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ ESP32 ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á "‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô" (‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏°‡∏≤‡πÄ‡∏£‡πá‡∏ß‡πÜ)

- ### Task: ‡∏Ñ‡∏∑‡∏≠ "‡∏á‡∏≤‡∏ô" ‡∏´‡∏£‡∏∑‡∏≠‡∏á‡∏≤‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡πÜ ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¥‡∏™‡∏£‡∏∞‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô (‡πÄ‡∏ä‡πà‡∏ô Task A ‡∏Ñ‡∏∏‡∏°‡πÑ‡∏ü, Task B ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå)

## ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà Task ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ:

- ### ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô ```void TenTask(void *param)```

- ### ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ Loop ```while(1)``` ‡∏´‡∏£‡∏∑‡∏≠ ```for(;;)```

- ### ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ ```vTaskDelay()``` ‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô Loop (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å! ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ Task ‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)

- ### ``` vTaskDelay(pdMS_TO_TICKS(ms)): ``` ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á  Delay ‡∏Ç‡∏≠‡∏á FreeRTOS (‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ ```delay()```)

### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á 2 Tasks)
```C

// 1. Task Function Prototypes (‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Task)
void Task1(void *param);
void Task2(void *param);

void setup() {
  Serial.begin(115200);

  // 3. Create Tasks (‡∏™‡∏£‡πâ‡∏≤‡∏á Task)
  // xTaskCreate( FunctionName, "TaskName", StackSize, Parameters, Priority, TaskHandle );
  xTaskCreate(
    Task1,        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ç‡∏≠‡∏á Task
    "Task LED 1", // ‡∏ä‡∏∑‡πà‡∏≠ Task
    1024,         // Stack size (‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥)
    NULL,         // Parameter ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏™‡πà NULL)
    1,            // Priority (‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç)
    NULL);        // Task handle (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏™‡πà NULL)
  
  xTaskCreate(
    Task2,
    "Task Serial",
    1024,
    NULL,
    1,
    NULL);
}

// 2. Task Definitions (‡∏ï‡∏±‡∏ß‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Task)
void Task1(void *param) {
  // (Setup code for this task)
  pinMode(2, OUTPUT);

  for (;;) { // Loop ‡∏ï‡∏•‡∏≠‡∏î‡πÑ‡∏õ
    // (Work code for this task)
    digitalWrite(2, HIGH);
    vTaskDelay(pdMS_TO_TICKS(500)); // Delay 500ms
    digitalWrite(2, LOW);
    vTaskDelay(pdMS_TO_TICKS(500));
  }
}

void Task2(void *param) {
  for (;;) {
    Serial.println("Task 2 is running...");
    vTaskDelay(pdMS_TO_TICKS(2000)); // Delay 2000ms
  }
}

void loop() {
  // ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤! ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ FreeRTOS ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß
}

```
---
## 2. ESPNOW (Weeks 9-11) üì°
- ### ‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡πÑ‡∏£‡πâ‡∏™‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö Peer-to-Peer (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ WiFi Router) ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 2 ‡∏ù‡∏±‡πà‡∏á: Sender ‡πÅ‡∏•‡∏∞ Receiver

## ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ã‡∏õ‡∏ï‡πå‡∏´‡∏•‡∏±‡∏Å:

- ### ‡πÉ‡∏ä‡πâ MAC Address ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏±‡∏ß‡∏ï‡∏ô (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå)

- ### ‡∏ï‡πâ‡∏≠‡∏á ```WiFi.mode(WIFI_STA)``` ‡∏Å‡πà‡∏≠‡∏ô

- ### ‡∏ï‡πâ‡∏≠‡∏á ```esp_now_init()```

- ### ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á ```struct``` (‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•) ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á 2 ‡∏ù‡∏±‡πà‡∏á

- ### Sender (‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á): ```‡∏ï‡πâ‡∏≠‡∏á esp_now_add_peer()``` (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô) ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ ```esp_now_send()```

- ### Receiver (‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö): ‡∏ï‡πâ‡∏≠‡∏á ```esp_now_register_recv_cb()```(‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)

## ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Sender - ‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á)

```C

#include <esp_now.h>
#include <WiFi.h>

// 1. MAC Address ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö (‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö)
uint8_t receiverMac[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};

// 2. Struct (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á‡∏£‡∏±‡∏ö)
typedef struct struct_message {
  int id;
  float temp;
} struct_message;

struct_message myData; // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏à‡∏≤‡∏Å struct

esp_now_peer_info_t peerInfo; // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á "‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô"

// 4. Callback function ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("Send status: ");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Success" : "Fail");
}

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA); // ‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏´‡∏°‡∏î STA

  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // 3. ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô Callback "‡∏™‡πà‡∏á"
  esp_now_register_send_cb(OnDataSent);

  // 5. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô (Add Peer)
  memcpy(peerInfo.peer_addr, receiverMac, 6);
  peerInfo.channel = 0;
  peerInfo.encrypt = false;
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("Failed to add peer");
    return;
  }
}

void loop() {
  // 6. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á
  myData.id = 123;
  myData.temp = 25.5;
  
  esp_err_t result = esp_now_send(receiverMac, (uint8_t *) &myData, sizeof(myData));
  
  delay(5000); // ‡∏™‡πà‡∏á‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
}

```
## ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Receiver - ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö)

```C

#include <esp_now.h>
#include <WiFi.h>

// 1. Struct (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á‡∏™‡πà‡∏á)
typedef struct struct_message {
  int id;
  float temp;
} struct_message;

struct_message myData; // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏à‡∏≤‡∏Å struct

// 3. Callback function ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏´‡∏•‡∏±‡∏Å)
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  memcpy(&myData, incomingData, sizeof(myData)); // ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏≤‡πÉ‡∏™‡πà‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
  Serial.print("Data received: ");
  Serial.print("ID: ");
  Serial.println(myData.id);
  Serial.print("Temp: ");
  Serial.println(myData.temp);
}
 s
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA); // ‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏´‡∏°‡∏î STA

  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // 2. ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô Callback "‡∏£‡∏±‡∏ö" (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
  esp_now_register_recv_cb(OnDataRecv);
}

void loop() {
  // ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤! ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏ô Callback (OnDataRecv)
}
```

## 3. MQTT (Weeks 9-11) üì¨
- ### ‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡πÅ‡∏ö‡∏ö Publish/Subscribe (‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ WiFi ‡πÅ‡∏•‡∏∞ Broker)

## ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ã‡∏õ‡∏ï‡πå‡∏´‡∏•‡∏±‡∏Å:

- ### Broker: ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á (‡πÄ‡∏ä‡πà‡∏ô ```broker.hivemq.com```)

- ### Publish (Pub): ‡∏Å‡∏≤‡∏£ "‡∏™‡πà‡∏á" ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á "‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠" (Topic)

- ### Subscribe (Sub): ‡∏Å‡∏≤‡∏£ "‡∏Ç‡∏≠‡∏£‡∏±‡∏ö" ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å "‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠" (Topic)

- ### Callback: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏ô Topic ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤ Sub ‡∏≠‡∏¢‡∏π‡πà

- ### ```client.loop():``` ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å! ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ô ```loop()``` ‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ MQTT ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô

## ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Pub & Sub)

```C

#include <WiFi.h>
#include <PubSubClient.h>

// 1. WiFi & MQTT Config
const char* ssid = "YOUR_SSID";
const char* password = "YOUR_PASSWORD";
const char* mqtt_server = "broker.hivemq.com"; // Broker

WiFiClient espClient;
PubSubClient client(espClient);

// 5. Callback function ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Sub)
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  payload[length] = '\0'; // ‡∏õ‡∏¥‡∏î‡∏ó‡πâ‡∏≤‡∏¢ String
  String message = (char*)payload;
  Serial.println(message);

  // ‡∏™‡∏±‡πà‡∏á‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö
  if (message == "ON") {
    digitalWrite(2, HIGH);
  } else if (message == "OFF") {
    digitalWrite(2, LOW);
  }
}

// 4. Reconnect Function (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WiFi ‡πÅ‡∏•‡∏∞ MQTT)
void reconnect() {
  while (!client.connected()) { // ‡∏ß‡∏ô‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ
    Serial.print("Attempting MQTT connection...");
    // Create a random client ID
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str())) {
      Serial.println("connected");
      // 4.1 Publish ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
      client.publish("my/test/topic", "Hello from ESP32");
      // 4.2 Subscribe Topic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
      client.subscribe("my/control/topic"); 
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

void setup() {
  pinMode(2, OUTPUT);
  Serial.begin(115200);

  // 2. Connect to WiFi
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");

  // 3. Setup MQTT
  client.setServer(mqtt_server, 1883); // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Broker
  client.setCallback(callback); // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Callback (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Sub)
}

void loop() {
  // 6. Check Connection (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å!)
  if (!client.connected()) {
    reconnect();
  }
  client.loop(); // (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å!)

  // 7. Publish (‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥)
  static long lastMsg = 0;
  long now = millis();
  if (now - lastMsg > 5000) {
    lastMsg = now;
    
    float temp = 25.7; // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏Ñ‡πà‡∏≤
    char msg[50];
    sprintf(msg, "Temperature: %.2f", temp); // ‡πÅ‡∏õ‡∏•‡∏á float ‡πÄ‡∏õ‡πá‡∏ô string
    
    Serial.print("Publish message: ");
    Serial.println(msg);
    client.publish("my/sensor/topic", msg);
  }
}
```

## 4. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô/‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á C ‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏à‡∏î‡∏à‡∏≥ (Misc)
- ### ‡πÅ‡∏õ‡∏•‡∏á Float ‡πÄ‡∏õ‡πá‡∏ô String (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö MQTT):

```C

float f = 25.123;
char buffer[10];
dtostrf(f, 4, 2, buffer); // (‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£, ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏£‡∏ß‡∏°, ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°, ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö) -> "25.12"
// ‡∏´‡∏£‡∏∑‡∏≠
sprintf(buffer, "%.2f", f);
```
- ### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Struct (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESPNOW):

```C

typedef struct my_struct {
  int a;
  float b;
  char c[10];
} my_struct;

my_struct data_to_send;
data_to_send.a = 10;
data_to_send.b = 1.23;
strcpy(data_to_send.c, "Hello");
```

- ### ‡∏Å‡∏≤‡∏£ Copy Struct (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESPNOW):

```C

// (‡πÉ‡∏ô OnDataRecv)
my_struct received_data;
memcpy(&received_data, incomingData, sizeof(received_data));
// ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ received_data.a, .b, .c ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß
```

- ### ‡∏´‡∏≤ MAC Address ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESPNOW):

```C

// (‡πÉ‡∏ô setup)
Serial.print("My MAC Address: ");
Serial.println(WiFi.macAddress());
```


## 5. ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô Hardware (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Wk 9-12)
- ## 5.1 ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå (GPIO - Digital Input) üîò
- ### ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á "‡∏Å‡∏î" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏õ‡∏™‡∏±‡πà‡∏á‡∏á‡∏≤‡∏ô ESPNOW ‡∏´‡∏£‡∏∑‡∏≠ Task ‡∏≠‡∏∑‡πà‡∏ô ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ã‡∏õ‡∏ï‡πå: ‡πÉ‡∏ä‡πâ INPUT_PULLUP ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ ESP32 ‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏ü‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏á‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏° (Active LOW) ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≠ R ‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å

![licensed-image.jpg](licensed-image.jpg)

---

- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Internal Pull-up):

```C
#define BUTTON_PIN 15 // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡πÉ‡∏ä‡πâ Pin 15

void setup() {
  pinMode(BUTTON_PIN, INPUT_PULLUP);
}

void loop() {
  // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°
  // HIGH (1) = ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏î (‡πÄ‡∏û‡∏£‡∏≤‡∏∞ PULLUP)
  // LOW (0)  = ‡∏Å‡∏î
  if (digitalRead(BUTTON_PIN) == LOW) {
    // ‡∏õ‡∏∏‡πà‡∏°‡∏ñ‡∏π‡∏Å‡∏Å‡∏î
    Serial.println("Button Pressed!");
    delay(50); // ‡∏Å‡∏±‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏±‡πà‡∏ô (Debounce)
  }
}

// **‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö:**
// ‡πÄ‡∏≠‡∏≤‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç if (digitalRead(...) == LOW)
// ‡πÑ‡∏õ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô loop() ‡∏Ç‡∏≠‡∏á Sender ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á esp_now_send()
// ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô Task ‡∏Ç‡∏≠‡∏á FreeRTOS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡πá‡∏Ñ‡∏õ‡∏∏‡πà‡∏°
```

- ## 5.2 ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ Analog (ADC) / LDR ‚òÄÔ∏è
- ### ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Analog (‡πÄ‡∏ä‡πà‡∏ô LDR, ‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÑ‡∏î‡πâ) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏ú‡πà‡∏≤‡∏ô ESPNOW ‡∏´‡∏£‡∏∑‡∏≠ MQTT ‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ã‡∏õ‡∏ï‡πå LDR: LDR (Light Dependent Resistor)

- ### ‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏°‡∏≤‡∏Å -> ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô‡∏ï‡πà‡∏≥

- ### ‡∏°‡∏∑‡∏î‡∏°‡∏≤‡∏Å -> ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô‡∏™‡∏π‡∏á ‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏ß‡∏á‡∏à‡∏£: ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≠‡πÅ‡∏ö‡∏ö Voltage Divider (‡πÅ‡∏ö‡πà‡∏á‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô" ‡πÄ‡∏õ‡πá‡∏ô "‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô" ‡πÉ‡∏´‡πâ ESP32 ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ

![alt text](<licensed-image (1).jpg>)

- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR/ADC):

```C
#define LDR_PIN 34 // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡πÉ‡∏ä‡πâ Pin 34 (‡πÄ‡∏õ‡πá‡∏ô ADC Pin)

void setup() {
  Serial.begin(115200);
}

void loop() {
  // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ Analog (ESP32 ‡∏°‡∏µ 12-bit ADC)
  int sensorValue = analogRead(LDR_PIN);
  // ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 (0V) ‡∏ñ‡∏∂‡∏á 4095 (3.3V)

  Serial.print("Analog Value: ");
  Serial.println(sensorValue);

  // (Optional) ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Voltage
  // float voltage = sensorValue * (3.3 / 4095.0);

  delay(1000);
}

// **‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö:**
// ‡πÄ‡∏≠‡∏≤ int sensorValue = analogRead(LDR_PIN);
// ‡πÑ‡∏õ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô loop() ‡∏Ç‡∏≠‡∏á Sender ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏™‡πà struct myData.temp = sensorValue;
// ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô Task ‡∏Ç‡∏≠‡∏á FreeRTOS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
```

## 6. Flowchart: ESPNOW (Receiver - ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö)

![alt text](<licensed-image (2).jpg>)

## ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö:

- ### Setup: ‡∏ó‡∏≥‡πÅ‡∏Ñ‡πà 2 ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠ Init ‡πÅ‡∏•‡∏∞ Register Callback "OnDataRecv"

- ### Loop: ‡∏°‡∏±‡∏Å‡∏à‡∏∞ "‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤" (Idle) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏∞‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô Callback

- ### OnDataRecv (Callback): ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏´‡∏•‡∏±‡∏Å "‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥" ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡πÄ‡∏ä‡πà‡∏ô memcpy) ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ô‡∏µ‡πâ

## 6.1 Flowchart: ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ Analog/Button (‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô)
- ### Flowchart ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå (ADC) ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏∏‡πà‡∏° (GPIO) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡πÑ‡∏õ‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ

![alt text](<licensed-image (3).jpg>)

## 6.2 Flowchart: ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á FreeRTOS (2 Tasks)
![alt text](images.png)
## ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö:

- ### Setup: ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠ "‡∏™‡∏£‡πâ‡∏≤‡∏á" Task ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á

- ### Scheduler: ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á FreeRTOS ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏Ñ‡∏≠‡∏¢‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Task 1 ‡πÅ‡∏•‡∏∞ Task 2

- ### Task Loop: ‡πÅ‡∏ï‡πà‡∏•‡∏∞ Task ‡∏à‡∏∞‡∏°‡∏µ Loop while(1) ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á ‡πÅ‡∏•‡∏∞‡∏à‡∏∞ "‡∏Ñ‡∏∑‡∏ô" ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÉ‡∏´‡πâ Scheduler ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏à‡∏≠ vTaskDelay()

## 6.3 Flowchart: ESPNOW (Sender - ‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á)
![alt text](images.jpg)

## ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö:

- ### Setup: ‡∏Ñ‡∏∑‡∏≠‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡∏∏‡πà‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡∏ï‡πâ‡∏≠‡∏á Init, Add Peer, ‡πÅ‡∏•‡∏∞ Register Callback "OnDataSent"

- ### Loop: ‡∏Ñ‡∏∑‡∏≠‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡∏Ñ‡∏≠‡∏¢‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡πÄ‡∏ä‡πà‡∏ô ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR) ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏±‡πà‡∏á esp_now_send()

- ### OnDataSent (Callback): ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà "‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥" ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å ‡∏™‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏à‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß

## 7 Simple Web Server (‡∏≠‡∏µ‡∏Å‡∏´‡∏ô‡∏∂‡πà‡∏á Application Wk 9-11)

- ### ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å MQTT ‡πÅ‡∏ï‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ ESP32 ‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏ú‡πà‡∏≤‡∏ô WiFi ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏µ‡∏Å‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏ï‡πá‡∏á‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ESP32 ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô "‡πÄ‡∏ß‡πá‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô Browser (‡πÄ‡∏ä‡πà‡∏ô ‡∏Ñ‡∏∏‡∏°‡πÑ‡∏ü)

- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Web Server ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° LED):

```C
#include <WiFi.h>

// 1. WiFi Config
const char* ssid = "YOUR_SSID";
const char* password = "YOUR_PASSWORD";

WiFiServer server(80); // ‡∏™‡∏£‡πâ‡∏≤‡∏á Server ‡∏ó‡∏µ‡πà Port 80

#define LED_PIN 2 // LED ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏Ñ‡∏∏‡∏°

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // 2. Connect to WiFi
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP()); // *‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏î IP ‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô Browser*

  server.begin(); // 3. Start Server
}

void loop() {
  WiFiClient client = server.available(); // 4. ‡∏£‡∏≠ Client (Browser) ‡∏ï‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤

  if (client) {
    Serial.println("New Client.");
    String currentLine = "";
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        if (c == '\n') {
          if (currentLine.length() == 0) {
            // 6. ‡∏™‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö (HTML) ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
            client.println("HTTP/1.1 200 OK");
            client.println("Content-type:text/html");
            client.println();
            
            // UI ‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡πá‡∏ö
            client.println("<html><body><h1>ESP32 Web Server</h1>");
            client.println("<p><a href=\"/on\"><button>Turn ON</button></a></p>");
            client.println("<p><a href=\"/off\"><button>Turn OFF</button></a></p>");
            client.println("</body></html>");
            client.println();
            break;
          } else {
            currentLine = "";
          }
        } else if (c != '\r') {
          currentLine += c;
        }

        // 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Request ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
        if (currentLine.endsWith("GET /on")) {
          digitalWrite(LED_PIN, HIGH);
          Serial.println("LED ON");
        }
        if (currentLine.endsWith("GET /off")) {
          digitalWrite(LED_PIN, LOW);
          Serial.println("LED OFF");
        }
      }
    }
    client.stop(); // ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    Serial.println("Client Disconnected.");
  }
}
```
## 8. ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (JSON)

- ### ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô ESPNOW ‡∏´‡∏£‡∏∑‡∏≠ MQTT ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡∏Ñ‡πà‡∏≤ (‡πÄ‡∏ä‡πà‡∏ô ID, Temp, Humidity) ‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ JSON ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏≥‡∏ó‡∏µ‡πà "‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ ```sprintf```)

- ### ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ Library: ```ArduinoJson.h```

- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (‡∏™‡∏£‡πâ‡∏≤‡∏á JSON ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á)

```C
#include <ArduinoJson.h>

// ‡∏™‡∏£‡πâ‡∏≤‡∏á JSON
StaticJsonDocument<200> doc; // 200 ‡∏Ñ‡∏∑‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î (‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡πÑ‡∏ß‡πâ)

// 1. ‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
doc["id"] = 101;
doc["sensor"] = "LDR";
doc["value"] = analogRead(34);

// 2. ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô String
char jsonOutput[128];
serializeJson(doc, jsonOutput);

// 3. ‡∏™‡πà‡∏á String ‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡∏ó‡∏≤‡∏á MQTT ‡∏´‡∏£‡∏∑‡∏≠ ESPNOW
// client.publish("my/topic", jsonOutput);
// ‡∏´‡∏£‡∏∑‡∏≠ esp_now_send(... (uint8_t*)jsonOutput, strlen(jsonOutput));
Serial.println(jsonOutput); 
// ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: {"id":101,"sensor":"LDR","value":1234}
```

- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (‡∏≠‡πà‡∏≤‡∏ô JSON ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏°‡∏≤)

```C
// (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö String ‡∏ä‡∏∑‡πà‡∏≠ incomingMessage)
// char* incomingMessage = "{\"id\":101,\"value\":1234}";

StaticJsonDocument<200> doc;

// 1. ‡∏≠‡πà‡∏≤‡∏ô String (Deserialize)
DeserializationError error = deserializeJson(doc, incomingMessage);

if (error) {
  Serial.print("deserializeJson() failed: ");
  Serial.println(error.c_str());
  return;
}

// 2. ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏ä‡πâ
int id = doc["id"]; // 101
int val = doc["value"]; // 1234

Serial.print("ID: "); Serial.println(id);
Serial.print("Value: "); Serial.println(val);
```
## 9.FreeRTOS (‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏Å‡∏±‡∏ô‡πÄ‡∏´‡∏ô‡∏µ‡∏¢‡∏ß)

### ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ß‡πà‡∏≤ "‡∏ñ‡πâ‡∏≤ Task 2 ‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≠‡∏á ‡∏£‡∏≠ ‡∏Å‡∏±‡∏ô ‡∏´‡∏£‡∏∑‡∏≠ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏´‡∏≤‡∏Å‡∏±‡∏ô" ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏≠‡∏∞‡πÑ‡∏£?

- ### Queue (‡∏Ñ‡∏¥‡∏ß):

    - ### ‡πÉ‡∏ä‡πâ‡∏ó‡∏≥‡πÑ‡∏°: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•" ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Task

    - ### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: Task A ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR ‡πÅ‡∏•‡πâ‡∏ß "‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤" (‡πÉ‡∏™‡πà‡∏Ñ‡∏¥‡∏ß) ‡πÑ‡∏õ‡πÉ‡∏´‡πâ Task B ‡πÄ‡∏≠‡∏≤‡πÑ‡∏õ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì

- ### Semaphore (‡πÄ‡∏ã‡∏°‡∏≤‡∏ü‡∏≠‡∏£‡πå):

    - ### ‡πÉ‡∏ä‡πâ‡∏ó‡∏≥‡πÑ‡∏°: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì" (‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß) ‡∏´‡∏£‡∏∑‡∏≠ "‡∏à‡∏≠‡∏á‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£" (‡∏Å‡∏±‡∏ô‡πÉ‡∏ä‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô)

     - ### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: Task A ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠ Task B ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô Task B ‡∏Å‡πá‡∏à‡∏∞ "‡πÉ‡∏´‡πâ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì" (Give Semaphore) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡πÄ‡∏™‡∏£‡πá‡∏à Task A ‡∏ó‡∏µ‡πà "‡∏£‡∏≠" (Take Semaphore) ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡πá‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ

## 10. Timer Interrupts (‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á)
### ‡∏ñ‡πâ‡∏≤‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏°‡∏≤‡∏Å‡πÜ (‡∏ó‡∏µ‡πà ```vTaskDelay``` ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏û‡∏≠) ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏á‡∏≤‡∏ô‡πÅ‡∏ó‡∏£‡∏Å‡∏î‡πà‡∏ß‡∏ô‡πÜ ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏Ñ‡πâ‡∏î "‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏¢"

```C
hw_timer_t *timer = NULL; // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ Timer

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å "‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥" ‡πÄ‡∏°‡∏∑‡πà‡∏≠ Timer ‡∏ô‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö
void IRAM_ATTR onTimer() {
  // **‡∏´‡πâ‡∏≤‡∏°** ‡πÉ‡∏™‡πà Serial.print() ‡∏´‡∏£‡∏∑‡∏≠ delay() ‡πÉ‡∏ô‡∏ô‡∏µ‡πâ!
  // ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡πÄ‡∏£‡πá‡∏ß‡πÜ ‡πÄ‡∏ä‡πà‡∏ô
  digitalWrite(2, !digitalRead(2)); // ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏ü
}

void setup() {
  pinMode(2, OUTPUT);
  
  // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á Timer (‡πÉ‡∏ä‡πâ Timer 0, Prescaler 80)
  // (80 MHz / 80 = 1,000,000 ticks/sec)
  timer = timerBegin(0, 80, true); 
  
  // 2. ‡∏ú‡∏π‡∏Å Timer ‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô (Attach Interrupt)
  timerAttachInterrupt(timer, &onTimer, true); 
  
  // 3. ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (1,000,000 ticks = 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
  // ‡πÉ‡∏´‡πâ Interrupt ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
  timerAlarmWrite(timer, 1000000, true); // true = ‡∏ô‡∏±‡∏ö‡∏ß‡∏ô
  
  // 4. ‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö
  timerAlarmEnable(timer); 
}

void loop() {
  // ‡∏ß‡πà‡∏≤‡∏á‡πÜ ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏õ
}
```

### GPIO ‡∏¢‡πà‡∏≠‡∏°‡∏≤‡∏à‡∏≤‡∏Å General Purpose Input/Output ‡∏Ñ‡∏£‡∏±‡∏ö

- ### G = General Purpose (‡∏≠‡πÄ‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå)

- ### P = Purpose (‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå)

- ### I = Input (‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)

- ### O = Output (‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)

### ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏Ç‡∏≤ GPIO ‡πÉ‡∏î‡πÜ ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô:

- ### Input (‡∏≠‡∏¥‡∏ô‡∏û‡∏∏‡∏ï): ‡πÄ‡∏û‡∏∑‡πà‡∏≠ "‡∏≠‡πà‡∏≤‡∏ô" ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡πÇ‡∏•‡∏Å‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å ‡πÄ‡∏ä‡πà‡∏ô ‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå (‡∏ß‡πà‡∏≤‡∏ñ‡∏π‡∏Å‡∏Å‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà) ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå üîò

- ### Output (‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏û‡∏∏‡∏ï): ‡πÄ‡∏û‡∏∑‡πà‡∏≠ "‡∏™‡πà‡∏á" ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÑ‡∏õ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÇ‡∏•‡∏Å‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å ‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡πÑ‡∏ü LED ‡∏ï‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏±‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏°‡∏∏‡∏ô üí°

### ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡∏Ñ‡∏∑‡∏≠ "‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡∏ä‡∏¥‡∏õ ‡∏°‡∏±‡∏ô‡∏°‡∏µ‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå‡∏≠‡∏¥‡πÄ‡∏•‡πá‡∏Å‡∏ó‡∏£‡∏≠‡∏ô‡∏¥‡∏Å‡∏™‡πå‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö"

- ### ‡∏Ç‡∏≤ GPIO ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≤ ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏Ñ‡πà "‡πÄ‡∏™‡πâ‡∏ô‡∏•‡∏ß‡∏î" ‡∏ï‡πà‡∏≠‡∏ï‡∏£‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á CPU ‡∏Ñ‡∏£‡∏±‡∏ö ‡πÅ‡∏ï‡πà‡∏°‡∏±‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö "‡∏ß‡∏á‡∏à‡∏£" ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ "‡∏™‡∏•‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î" ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ ‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡∏î‡∏π‡∏ß‡πà‡∏≤ 2 ‡πÇ‡∏´‡∏°‡∏î‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏¢‡∏±‡∏á‡πÑ‡∏á:
---

- ### 1. ‡πÇ‡∏´‡∏°‡∏î OUTPUT (‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏±‡πà‡∏á‡∏Å‡∏≤‡∏£ / "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏ö‡∏ô‡πâ‡∏≥") üíß
    - ### ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏∏‡∏ì‡∏™‡∏±‡πà‡∏á ```pinMode(pin, OUTPUT):```

    - ### ‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ ESP32 ‡∏ï‡πà‡∏≠‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏ö‡∏ô‡πâ‡∏≥" (‡∏ß‡∏á‡∏à‡∏£‡∏Ç‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡πÅ‡∏™ ‡∏´‡∏£‡∏∑‡∏≠ Push-Pull Driver) ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ä‡∏¥‡∏õ

    - ### ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á ```digitalWrite(pin, HIGH):``` ‡∏ä‡∏¥‡∏õ‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î "‡∏õ‡∏±‡πä‡∏°‡∏ô‡πâ‡∏≥" ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö ‡πÑ‡∏ü‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏á (3.3V) ‡∏≠‡∏±‡∏î‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡πÑ‡∏ü 3.3V ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ LED ‡∏ï‡∏¥‡∏î)

    - ### ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á ```digitalWrite(pin, LOW):``` ‡∏ä‡∏¥‡∏õ‡∏à‡∏∞‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡∏¥‡∏î "‡∏õ‡∏±‡πä‡∏°" ‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö ‡∏Å‡∏£‡∏≤‡∏ß‡∏î‡πå (0V) ‡∏î‡∏π‡∏î‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡πÑ‡∏ü‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡∏•‡∏á 0V ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ LED ‡∏î‡∏±‡∏ö)

- ### ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ô‡∏µ‡πâ ‡∏Ç‡∏≤ GPIO ‡∏à‡∏∞ "‡∏Ñ‡∏∏‡∏°‡πÄ‡∏Å‡∏°" 100% ‡∏°‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà ‡∏™‡∏£‡πâ‡∏≤‡∏á ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÑ‡∏ü‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏≠‡∏á‡∏Ñ‡∏£‡∏±‡∏ö
---
- ### 2. ‡πÇ‡∏´‡∏°‡∏î INPUT (‡πÇ‡∏´‡∏°‡∏î‡∏£‡∏±‡∏ö‡∏ü‡∏±‡∏á / "‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå") üéß
    - ###  ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏∏‡∏ì‡∏™‡∏±‡πà‡∏á ```pinMode(pin, INPUT):```

    - ### ‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ ESP32 "‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠" ‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏ö‡∏ô‡πâ‡∏≥" (‡∏ß‡∏á‡∏à‡∏£ Output) ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

    - ### ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö "‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ß‡∏±‡∏î‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô" (‡∏ß‡∏á‡∏à‡∏£‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì ‡∏´‡∏£‡∏∑‡∏≠ Input Buffer) ‡∏ó‡∏µ‡πà‡πÑ‡∏ß‡∏°‡∏≤‡∏Å‡πÅ‡∏ó‡∏ô

    - ### ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á ```digitalRead(pin):``` ‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á "‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤" ‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏ß‡πà‡∏≤ "‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡πÑ‡∏ü‡∏ó‡∏µ‡πà‡∏Ç‡∏≤ ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏Å‡∏•‡πâ 3.3V (HIGH) ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏Å‡∏•‡πâ 0V (LOW)?"

- ### ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ô‡∏µ‡πâ ‡∏Ç‡∏≤ GPIO ‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô "‡∏ú‡∏π‡πâ‡∏ü‡∏±‡∏á" ‡∏ó‡∏µ‡πà‡∏î‡∏µ ‡∏°‡∏±‡∏ô‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÑ‡∏ü‡πÉ‡∏î‡πÜ ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏£‡∏ö‡∏Å‡∏ß‡∏ô‡∏ß‡∏á‡∏à‡∏£‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å‡πÄ‡∏•‡∏¢ ‡∏°‡∏±‡∏ô‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏≠‡∏¢ "‡∏ü‡∏±‡∏á" ‡∏ß‡πà‡∏≤‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏°‡∏≤
---
- ### ‡∏™‡∏£‡∏∏‡∏õ "‡∏ó‡∏≥‡∏¢‡∏±‡∏á‡πÑ‡∏á"
- ### ```pinMode()``` ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ "‡∏™‡∏±‡∏ö‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå"

    - ### ```pinMode(pin, OUTPUT):``` ‡∏™‡∏±‡∏ö‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏ß‡∏á‡∏à‡∏£ "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏π‡∏ö‡∏ô‡πâ‡∏≥" (Push-Pull Driver)

    - ### ```pinMode(pin, INPUT):``` ‡∏™‡∏±‡∏ö‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏ß‡∏á‡∏à‡∏£ "‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå" (Input Buffer)

- ### ‡∏ß‡∏á‡∏à‡∏£‡∏™‡∏•‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ß‡πà‡∏≤ Tri-State Buffer ‡∏Ñ‡∏£‡∏±‡∏ö ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏±‡∏ô‡∏°‡∏µ 3 ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:

    - ### HIGH (‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö 3.3V)

    - ### LOW (‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö 0V)

    - ### High-Impedance ‡∏´‡∏£‡∏∑‡∏≠ Hi-Z (‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà 3) - ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏´‡∏°‡∏î INPUT ‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡∏´‡∏°‡∏î ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏ï‡πà "‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå" ‡∏Ñ‡∏£‡∏±‡∏ö

#

### 1. ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ R ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LED (‡∏Å‡∏±‡∏ô LED ‡∏Ç‡∏≤‡∏î)
- ### ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÇ‡∏•‡∏Å‡∏Ç‡∏≠‡∏á‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡πÄ‡∏•‡∏≠‡∏£‡πå ‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏à‡∏∞‡∏°‡∏≤‡πÅ‡∏ô‡∏ß‡πÑ‡∏´‡∏ô: "‡∏à‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î FreeRTOS ‡πÉ‡∏´‡πâ Task 1 ‡∏™‡∏±‡πà‡∏á‡πÑ‡∏ü LED ‡∏Å‡∏∞‡∏û‡∏£‡∏¥‡∏ö... (‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏°‡∏µ‡∏ß‡∏á‡∏à‡∏£‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡∏¥‡∏°‡∏Ñ‡πà‡∏≤ R)"

- ### ‡∏™‡∏π‡∏ï‡∏£ (‡∏Å‡∏é‡∏Ç‡∏≠‡∏á‡πÇ‡∏≠‡∏´‡πå‡∏°):
    $$R = (V_{source} - V_{f}) / I_{f}$$
### ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏î:
- ### $V_{source}$ (‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡πÅ‡∏´‡∏•‡πà‡∏á‡∏à‡πà‡∏≤‡∏¢):
    - ### ‡∏Ç‡∏≤ GPIO ‡∏Ç‡∏≠‡∏á ESP32 ‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏ü 3.3V (‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤ $V_{source}$)
- ### $V_{f}$ (Forward Voltage):
    - ### ‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡∏ó‡∏µ‡πà LED "‡∏Å‡∏¥‡∏ô" (‡∏à‡∏∞‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡∏™‡∏µ)
    - ### ‡∏à‡∏î‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏≤‡∏á‡πÜ ‡πÑ‡∏õ‡πÄ‡∏•‡∏¢: ‡πÑ‡∏ü LED ‡∏™‡∏µ‡πÅ‡∏î‡∏á/‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß/‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á: $V_{f} \approx 2.0V$
- ### $I_{f}$ (Forward Current):
    - ### ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡πÅ‡∏™‡∏ó‡∏µ‡πà LED ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡∏ñ‡πâ‡∏≤‡∏°‡∏≤‡∏Å‡πÑ‡∏õ LED ‡∏à‡∏∞‡∏Ç‡∏≤‡∏î)
    - ### ‡∏à‡∏î‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢: $I_{f} = 0.01A$ (‡∏Ñ‡∏∑‡∏≠ 10mA) ‡∏´‡∏£‡∏∑‡∏≠ 0.02A (20mA)
- ### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (‡∏à‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÄ‡∏•‡∏¢):‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠ LED ‡∏™‡∏µ‡πÅ‡∏î‡∏á ($V_{f} = 2.0V$) ‡∏Å‡∏±‡∏ö‡∏Ç‡∏≤ ESP32 ($V_{source} = 3.3V$) ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏Å‡∏£‡∏∞‡πÅ‡∏™ $I_{f} = 10mA$ (0.01A) 

    $$R = (3.3V - 2.0V) / 0.01A$$
    $$R = 1.3V / 0.01A$$
    $$R = 130 \Omega$$
- ### ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö: ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ R ‡∏Ñ‡πà‡∏≤ $130 \Omega$ (‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á ‡πÄ‡∏ä‡πà‡∏ô $150 \Omega$ ‡∏´‡∏£‡∏∑‡∏≠ $220 \Omega$)

![alt text](licensed-image(4).jpg)

### 2. ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏á‡∏à‡∏£‡πÅ‡∏ö‡πà‡∏á‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô (Voltage Divider)
- ### ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÅ‡∏ö‡∏ö Analog ‡πÄ‡∏ä‡πà‡∏ô LDR (‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô‡πÅ‡∏õ‡∏£‡∏ï‡∏≤‡∏°‡πÅ‡∏™‡∏á) ‡∏´‡∏£‡∏∑‡∏≠ Potentiometer (‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô‡∏´‡∏°‡∏∏‡∏ô‡πÑ‡∏î‡πâ) ‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏à‡∏∞‡∏°‡∏≤‡πÅ‡∏ô‡∏ß‡πÑ‡∏´‡∏ô: "‡∏à‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î ESPNOW ‡πÉ‡∏´‡πâ Sender ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÉ‡∏´‡πâ Receiver..." (‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ‡∏ß‡∏á‡∏à‡∏£‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠ "‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR" ‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏Å‡πà‡∏≠‡∏ô)

### ‡∏™‡∏π‡∏ï‡∏£ (Voltage Divider):
$$V_{out} = V_{in} \times (R_2 / (R_1 + R_2))$$
### ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏î:
- ### $V_{in}$ (‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤):
    - ### ‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏´‡∏•‡πà‡∏á‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏ü‡πÉ‡∏´‡πâ‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå ‡∏õ‡∏Å‡∏ï‡∏¥‡∏Ñ‡∏∑‡∏≠ 3.3V ‡∏à‡∏≤‡∏Å‡∏ö‡∏≠‡∏£‡πå‡∏î ESP32
- ### $R_1$: ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô "‡∏Ñ‡∏á‡∏ó‡∏µ‡πà" ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÉ‡∏™‡πà‡πÑ‡∏õ ( ‡πÄ‡∏ä‡πà‡∏ô $10,000 \Omega$ )
- ### $R_2$: ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô "‡πÅ‡∏õ‡∏£‡∏ú‡∏±‡∏ô" (‡∏ï‡∏±‡∏ß‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå ‡πÄ‡∏ä‡πà‡∏ô LDR)
- ### $V_{out}$: ‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏£‡∏á‡∏î‡∏±‡∏ô‡∏ó‡∏µ‡πà "‡πÅ‡∏ö‡πà‡∏á" ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÑ‡∏î‡πâ ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏ï‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡∏≤ ADC (‡πÄ‡∏ä‡πà‡∏ô GPIO 34) ‡∏Ç‡∏≠‡∏á ESP32 ‡πÄ‡∏û‡∏∑‡πà‡∏≠ ```analogRead()```
### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (‡∏à‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ):
- ### ‡πÄ‡∏£‡∏≤‡∏ï‡πà‡∏≠ $V_{in} = 3.3V$
- ### ‡πÉ‡∏ä‡πâ $R_1 = 10,000 \Omega$ (10k)
- ### ‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏∑‡∏î LDR ($R_2$) ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ $20,000 \Omega$ (20k)
- ### ‡πÄ‡∏£‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ $V_{out}$ ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡∏≤ ADC ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà?
$$V_{out} = 3.3V \times (20,000 / (10,000 + 20,000))$$
$$V_{out} = 3.3V \times (20,000 / 30,000)$$
$$V_{out} = 3.3V \times 0.667$$
$$V_{out} \approx 2.2V$$

- ### ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö: ESP32 ‡∏à‡∏∞‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ $V_{out}$ ‡πÑ‡∏î‡πâ 2.2V ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ```analogRead()``` ‡∏à‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏î‡∏¥‡∏à‡∏¥‡∏ó‡∏±‡∏• (‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì $\frac{2.2V}{3.3V} \times 4095 \approx 2730$)
![alt text](<licensed-image (4).jpg>)

### ‡∏™‡∏£‡∏∏‡∏õ: ‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏≤‡∏°‡∏ß‡πà‡∏≤ "‡∏à‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì KVL" ‡πÅ‡∏ï‡πà‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏ß‡πà‡∏≤ "‡∏à‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î ESPNOW ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤ LDR" ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ ‡∏ß‡∏á‡∏à‡∏£‡∏ó‡∏µ‡πà 2 (Voltage Divider) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR ‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠ "‡∏à‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î FreeRTOS ‡∏Å‡∏∞‡∏û‡∏£‡∏¥‡∏ö‡πÑ‡∏ü" ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ ‡∏ß‡∏á‡∏à‡∏£‡∏ó‡∏µ‡πà 1 (LED Resistor) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡πà‡∏≠‡∏ß‡∏á‡∏à‡∏£‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö


## ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
- ### ‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î (Queue ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤ int ‡∏à‡∏≤‡∏Å Task A ‡πÑ‡∏õ Task B)
```C
#include <Arduino.h>

QueueHandle_t myQueue; // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ Queue

void TaskA_Sender(void *param);
void TaskB_Receiver(void *param);

#define LDR_PIN 34

void setup() {
  Serial.begin(115200);
  
  // 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á Queue (‡∏Ç‡∏ô‡∏≤‡∏î 10 ‡∏ä‡πà‡∏≠‡∏á, ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ä‡∏ô‡∏¥‡∏î int)
  myQueue = xQueueCreate(10, sizeof(int));

  if (myQueue != NULL) {
    xTaskCreate(TaskA_Sender, "Sender", 2048, NULL, 1, NULL);
    xTaskCreate(TaskB_Receiver, "Receiver", 2048, NULL, 1, NULL);
  } else {
    Serial.println("Failed to create queue");
  }
}

// Task A: ‡∏≠‡πà‡∏≤‡∏ô LDR ‡πÅ‡∏•‡πâ‡∏ß "‡∏™‡πà‡∏á" ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏¥‡∏ß
void TaskA_Sender(void *param) {
  for (;;) {
    int ldrValue = analogRead(LDR_PIN); // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ LDR
    Serial.printf("Task A: Sending value %d\n", ldrValue);

    // 3. ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤ (ldrValue) ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô myQueue
    // (‡∏£‡∏≠‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10 ticks ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏ï‡πá‡∏°)
    xQueueSend(myQueue, &ldrValue, pdMS_TO_TICKS(10)); 
    
    vTaskDelay(pdMS_TO_TICKS(1000)); // ‡∏ó‡∏≥‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
  }
}

// Task B: "‡∏£‡∏≠‡∏£‡∏±‡∏ö" ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏Ñ‡∏¥‡∏ß ‡πÅ‡∏•‡πâ‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå
void TaskB_Receiver(void *param) {
  int receivedValue;
  for (;;) {
    // 4. ‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å myQueue (‡∏à‡∏∞‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡∏°‡∏≤)
    if (xQueueReceive(myQueue, &receivedValue, portMAX_DELAY)) {
      Serial.printf("Task B: Received value = %d\n", receivedValue);
      // ‡πÄ‡∏≠‡∏≤ receivedValue ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
    }
  }
}

void loop() {}
```